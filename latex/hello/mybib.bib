@article{Lee2007,
abstract = {We present an internal language with equivalent expressive power to Standard ML, and discuss its formalization in LF and the machine-checked verification of its type safety in Twelf. The internal language is intended to serve as the target of elaboration in an elaborative semantics for Standard ML in the style of Harper and Stone. Therefore, it includes all the programming mechanisms necessary to implement Standard ML, including translucent modules, abstraction, polymorphism, higher kinds, references, exceptions, recursive types, and recursive functions. Our successful formalization of the proof involved a careful interplay between the precise formulations of the various mechanisms, and required the invention of new representation and proof techniques of general interest.},
author = {Lee, Daniel K and Crary, Karl and Harper, Robert},
doi = {10.1145/1190215.1190245},
isbn = {1595935754},
issn = {03621340},
journal = {ACM Sigplan Notices},
keywords = {anized metatheory,language definitions,logical frameworks,mech,standard ml,twelf,type safety},
number = {1},
pages = {173--184},
publisher = {ACM},
series = {POPL '07},
title = {{Towards a mechanized metatheory of standard ML}},
url = {http://portal.acm.org/citation.cfm?doid=1190215.1190245},
volume = {42},
year = {2007}
}
@inproceedings{Odersky2006,
author = {Odersky, Martin},
booktitle = {Presentation at the meeting of IFIP WG},
file = {::},
number = {July},
pages = {8--boston06pdf},
title = {{Poor Man's Type Classes}},
url = {http://lamp.epfl.ch/~odersky/talks/wg2.8-boston06.pdf},
volume = {2},
year = {2006}
}
@inproceedings{Peterson1993,
abstract = {We describe the implementation of a type checker for the functional programming language Haskell that supports the use of type classes. This extends the type system of ML to support overloading (ad-hoc polymorphism) and can be used to implement features such as equality types and numeric overloading in a simple and general way. The theory of type classes is well understood, but the practical issues involved in the implementation of such systems have not received a great deal of attention. In addition to the basic type checking algorithm, an implmenentation of type classes also requires some form of program transformation. In all current Haskell compilers this takes the form of dictionary conversion, using functions as hidden parameters to overloaded values. We present efficient techniques for type checking and dictionary conversion. A number of optimizations and extensions to the basic type class sytems are also described.},
author = {Peterson, John and Jones, Mark},
booktitle = {ACM Sigplan Notices},
doi = {10.1145/173262.155112},
isbn = {0897915984},
issn = {03621340},
number = {6},
pages = {227--236},
publisher = {ACM},
series = {PLDI '93},
title = {{Implementing type classes}},
url = {http://portal.acm.org/citation.cfm?doid=173262.155112},
volume = {28},
year = {1993}
}
@article{Rossberg2001,
author = {Rossberg, Andreas and Sulzmann, Martin},
institution = {Citeseer},
journal = {Engineering},
publisher = {Citeseer},
title = {{Beyond Type Classes}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.57.6224\&amp;rep=rep1\&amp;type=pdf},
year = {2001}
}
@article{Harper2010,
abstract = {This is a working draft of a book on the foundations of programming languages. The central organizing principle of the book is that programming language features may be seen as manifestations of an underlying type structure that governs its syntax and semantics. The emphasis, therefore, is on the concept of type, which codifies and organizes the computational universe in much the same way that the concept of set may be seen as an organizing principle for the mathematical universe. The purpose of this book is to explain this remark.},
author = {Harper, Robert},
journal = {available wwwcscmuedurwhplbookbookpdf 2009},
pages = {496},
publisher = {Carnegie Mellon University},
title = {{Practical Foundations for Programming Languages}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.132.5853\&amp;rep=rep1\&amp;type=pdf},
year = {2010}
}
@article{Dreyer2007,
abstract = {ML modules and Haskell type classes have proven to be highly effective tools for program structuring. Modules emphasize explicit configuration of program components and the use of data abstraction. Type classes emphasize implicit program construction and ad hoc polymorphism. In this paper, we show how the implicitly-typed style of type class programming may be supported within the framework of an explicitly-typed module language by viewing type classes as a particular mode of use of modules. This view offers a harmonious integration of modules and type classes, where type class features, such as class hierarchies and associated types, arise naturally as uses of existing module-language constructs, such as module hierarchies and type components. In addition, programmers have explicit control over which type class instances are available for use by type inference in a given scope. We formalize our approach as a Harper-Stone-style elaboration relation, and provide a sound type inference algorithm as a guide to implementation.},
author = {Dreyer, Derek and Harper, Robert and Chakravarty, Manuel M T and Keller, Gabriele},
doi = {10.1145/1190215.1190229},
isbn = {1595935754},
issn = {03621340},
journal = {ACM Sigplan Notices},
number = {1},
pages = {63},
publisher = {ACM},
series = {POPL '07},
title = {{Modular type classes}},
url = {http://portal.acm.org/citation.cfm?doid=1190215.1190229},
volume = {42},
year = {2007}
}
@article{Gabbay2002,
abstract = {Abstract. The permutation model of set theory with atoms (FM-sets), devised by Fraenkel and Mostowski in the 1930s, supports notions of name-abstraction and fresh name that provide a new way to represent, compute with, and reason about the syntax of formal systems involving variable-binding operations. Inductively defined FM-sets involving the name-abstraction set former (together with Cartesian product and disjoint union) can correctly encode syntax modulo renaming of bound variables. In this way, the standard theory of algebraic data types can be extended to encompass signatures involving binding operators. In particular, there is an associated notion of structural recursion for defining syntax-manipulating functions (such as capture avoiding substitution, set of free variables, etc.) and a notion of proof by structural induction, both of which remain pleasingly close to informal practice in computer science.},
author = {Gabbay, Murdoch J and Pitts, Andrew M},
doi = {10.1007/s001650200016},
issn = {09345043},
journal = {Formal Aspects of Computing},
number = {3-5},
pages = {341--363},
title = {{A New Approach to Abstract Syntax with Variable Binding}},
url = {http://www.springerlink.com/openurl.asp?genre=article\&id=doi:10.1007/s001650200016},
volume = {13},
year = {2002}
}
